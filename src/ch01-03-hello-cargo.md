## Merhaba, Cargo!

Cargo, Rust'ın yapı sistemi ve paket yöneticisidir. Çoğu Rustacean
Rust projelerini yönetmek için bu aracı kullanır çünkü Cargo
kodunuzu oluşturmak kodunuzun bağlı olduğu kütüphaneleri indirmek ve
bu kütüphaneleri oluşturmak gibi birçok görevi sizin için yerine getirir. (Kodunuzun ihtiyaç duyduğu kütüphanelere
_dependencies_ diyoruz).

Şimdiye kadar yazdığımız gibi en basit Rust programlarının herhangi bir
bağımlılığı yoktur. “Hello, world!” projesini Cargo ile oluşturmuş olsaydık,
sadece Cargo'nun kodunuzu oluşturmayı yöneten kısmını kullanacaktı. Daha
karmaşık Rust programları yazdıkça, bağımlılıklar ekleyeceksiniz ve Cargo kullanarak bir projeye
başlarsanız, bağımlılık eklemek çok daha kolay olacaktır.

Rust projelerinin büyük çoğunluğu Cargo kullandığından, bu kitabın geri kalanında
sizin de Cargo kullandığınız varsayılmaktadır. Eğer

 [“Kurulum”][installation]<!-- ignore --> bölümünde anlatılan resmi yükleyicileri kullandıysanız, Cargo Rust ile birlikte yüklü olarak gelir. Eğer Rust
'u başka bir yolla kurduysanız, terminalinize aşağıdaki
adresini girerek Cargo'nun kurulu olup olmadığını kontrol edin:

```console
$ cargo --version
```

Eğer bir sürüm numarası görüyorsanız, onu buldunuz demektir! Eğer `command
not found` gibi bir hata görürseniz,
Cargo'yu ayrı olarak nasıl yükleyeceğinizi belirlemek için yükleme yönteminizin belgelerine bakın.

### Cargo ile Proje Oluşturma

Cargo kullanarak yeni bir proje oluşturalım ve
orijinal “Hello, world!” projemizden ne kadar farklı olduğuna bakalım. _projects_ dizininize geri dönün
(veya kodunuzu nerede saklamaya karar verdiyseniz). Ardından, herhangi bir işletim sisteminde,
aşağıdakileri çalıştırın:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

İlk komut _hello_cargo_ adında yeni bir dizin ve proje oluşturur.
Projemize _hello_cargo_ adını verdik ve Cargo dosyalarını aynı adı taşıyan bir
dizininde oluşturur.

_hello_cargo_ dizinine gidin ve dosyaları listeleyin. Cargo'nun
bizim için iki dosya ve bir dizin oluşturduğunu göreceksiniz: bir_Cargo.toml_ dosyası ve içinde bir _main.rs_ dosyası bulunan bir
_src_ dizini.

Ayrıca bir _.gitignore_ dosyası ile birlikte yeni bir Git deposu da başlatmıştır.
Mevcut bir Git
deposu içinde `cargo new` çalıştırırsanız Git dosyaları oluşturulmayacaktır; `cargo new --vcs=git` kullanarak bu davranışı geçersiz kılabilirsiniz.

> Not: Git yaygın bir sürüm kontrol sistemidir. `cargo new`i
> farklı bir sürüm kontrol sistemi kullanacak şekilde değiştirebilir veya
> `--vcs` bayrağını kullanarak hiçbir sürüm kontrol sistemi kullanmayabilirsiniz. Mevcut seçenekleri görmek için `cargo new --help` komutunu çalıştırın.

_Cargo.toml_ dosyasını istediğiniz metin düzenleyicisinde açın. Liste 1-2'deki
koduna benzer görünmelidir.

<Listing number="1-2" file-name="Cargo.toml" caption="Contents of *Cargo.toml* generated by `cargo new`">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
```

</Listing>

Bu dosya, Cargo'nun yapılandırma biçimi olan [_TOML_][toml]<!-- ignore --> (_Tom's Obvious, Minimal
Language_) biçimindedir.

İlk satır, `[package]`, aşağıdaki ifadelerin
bir paketi yapılandırdığını gösteren bir bölüm başlığıdır. Bu dosyaya
daha fazla bilgi ekledikçe, başka bölümler de ekleyeceğiz.

Sonraki üç satır Cargo'nun
programınızı derlemek için ihtiyaç duyduğu yapılandırma bilgilerini belirler: kullanılacak Rust'ın adı, sürümü ve sürümü. adresinde `edition` anahtarından bahsedeceğiz [Ek E][appendix-e]<!-- ignore -->.

Son satır olan `[dependencies]`, projenizin bağımlılıklarını
adresinde listelemeniz için bir bölümün başlangıcıdır. Rust'ta kod paketleri
_crates_ olarak adlandırılır. Bu proje için başka bir kasaya ihtiyacımız olmayacak, ancak Bölüm 2'deki
ilk projede olacak, bu yüzden bu bağımlılıklar bölümünü o zaman kullanacağız.

Şimdi _src/main.rs_ dosyasını açın ve bir göz atın:

<span class="filename">Dosya adı: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo sizin için bir “Merhaba, dünya!” programı oluşturdu, tıpkı Liste 1-1'de
yazdığımız gibi! Şimdiye kadar, bizim projemiz ile Cargo'nun oluşturduğu
projesi arasındaki farklar, Cargo'nun kodu _src_ dizinine
yerleştirmesi ve üst dizinde bir .toml_ yapılandırma dosyamız olmasıdır.

Cargo, kaynak dosyalarınızın _src_ dizini içinde bulunmasını bekler. üst düzey proje dizini sadece README dosyaları, lisans bilgileri,
yapılandırma dosyaları ve kodunuzla ilgili olmayan diğer her şey içindir. Cargo'yu kullanmak
projelerinizi düzenlemenize yardımcı olur. Her şey için bir yer vardır ve
her şey kendi yerindedir.

“Hello,
world!” projesinde yaptığımız gibi Cargo kullanmayan bir proje başlattıysanız, bunu Cargo kullanan bir projeye dönüştürebilirsiniz. proje kodunu _src_ dizinine taşıyın ve uygun bir _Cargo.toml_
dosyası oluşturun. Bu _Cargo.toml_ dosyasını elde etmenin kolay bir yolu,
adresinin sizin için otomatik olarak oluşturacağı `cargo init` dosyasını çalıştırmaktır.

### Bir Kargo Projesi Oluşturma ve Yürütme

Şimdi “Hello, world!”
programını Cargo ile oluşturup çalıştırdığımızda nelerin farklı olduğuna bakalım! _hello_cargo_ dizininizden,
adresine aşağıdaki komutu girerek projenizi oluşturun:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

Bu komut, geçerli
dizininiz yerine _target/debug/hello_cargo_ (veya Windows'ta
_target\debug\hello_cargo.exe_) içinde çalıştırılabilir bir dosya oluşturur. Varsayılan derleme bir hata ayıklama derlemesi olduğundan, Cargo ikili dosyayı
_debug_ adlı bir dizine koyar. Çalıştırılabilir dosyayı bu komutla çalıştırabilirsiniz:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

Her şey yolunda giderse, `Hello, world!` terminalde yazdırılmalıdır. İlk kez `cargo
build` çalıştırıldığında, Cargo en üst
düzeyinde yeni bir dosya oluşturur: _COPYargo.lock_. Bu dosya, projenizdeki
bağımlılıklarının tam sürümlerini takip eder. Bu projenin bağımlılıkları yoktur, bu nedenle
dosyası biraz seyrektir. Bu dosyayı hiçbir zaman elle değiştirmeniz gerekmez; Cargo
içeriğini sizin için yönetir.

Az önce `cargo build` ile bir proje oluşturduk ve
`./target/debug/hello_cargo` ile çalıştırdık, ancak
kodunu derlemek ve ardından ortaya çıkan çalıştırılabilir dosyayı tek bir komutla çalıştırmak için `cargo run` da kullanabiliriz:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

`Cargo run` komutunu kullanmak, `cargo build` komutunu çalıştırmayı ve ardından ikili dosyanın tüm yolunu kullanmayı hatırlamaktan daha kullanışlıdır, bu nedenle çoğu geliştirici `cargo run` komutunu kullanır.

Bu sefer Cargo'nun
`hello_cargo` dosyasını derlediğini gösteren bir çıktı görmediğimize dikkat edin. Cargo dosyaların değişmediğini anladı, bu yüzden
yeniden oluşturmadı, sadece ikiliyi çalıştırdı. Kaynak kodunuzu değiştirmiş olsaydınız, Cargo
projeyi çalıştırmadan önce yeniden oluşturacaktı ve bu
çıktısını görecektiniz:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo ayrıca `cargo check` adında bir komut da sağlar. Bu komut
kodunuzun derlendiğinden ancak çalıştırılabilir bir dosya üretmediğinden emin olmak için hızlı bir şekilde kontrol eder:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Neden bir çalıştırılabilir dosya istemeyesiniz ki? Genellikle, `cargo check`
`cargo build` adresinden çok daha hızlıdır çünkü bir çalıştırılabilir dosya üretme adımını atlar. Eğer
kodu yazarken çalışmanızı sürekli kontrol ediyorsanız, `cargo check` kullanmak
projenizin hala derlenip derlenmediğini size bildirme sürecini hızlandıracaktır! gibi, birçok Rustacean, derlendiğinden emin olmak için
programlarını yazarken periyodik olarak `cargo check` çalıştırır. Daha sonra
çalıştırılabilir dosyayı kullanmaya hazır olduklarında `cargo build` çalıştırırlar.

Cargo hakkında şimdiye kadar öğrendiklerimizi özetleyelim:

- `Cargo new` kullanarak bir proje oluşturabiliriz.
- `cargo build` kullanarak bir proje oluşturabiliriz.
- Bir projeyi `cargo run` kullanarak tek adımda oluşturabilir ve çalıştırabiliriz.
-
 `cargo check` kullanarak hataları kontrol etmek için bir ikili üretmeden bir proje oluşturabiliriz.
- Derleme sonucunu kodumuzla aynı dizine kaydetmek yerine,
 Cargo bunu _target/debug_ dizininde saklar.

`Cargo kullanmanın bir diğer avantajı da komutların hangi işletim sisteminde çalışıyor olursanız olun aynı olmasıdır`. Dolayısıyla, bu noktada artık
adresinde Linux ve macOS ile Windows için özel talimatlar vermeyeceğiz.

### Sürüm için Hazırlık

Projeniz nihayet yayınlanmaya hazır olduğunda, `cargo build --release`
optimizasyonlarla derlemek için . Bu komut _target/debug_ yerine _target/release_ içinde bir
çalıştırılabilir dosyası oluşturacaktır. Optimizasyonlar
Rust kodunuzun daha hızlı çalışmasını sağlar, ancak bunları açmak programınızın derlenmesi için
gereken süreyi uzatır. Bu nedenle iki farklı profil vardır: biri
hızlı ve sık sık yeniden oluşturmak istediğinizde geliştirme için ve diğeri
tekrar tekrar yeniden oluşturulmayacak ve mümkün olduğunca hızlı çalışacak
bir kullanıcıya vereceğiniz son programı oluşturmak için. Eğer
kodunuzun çalışma süresini kıyaslıyorsanız, `cargo build --release` çalıştırdığınızdan ve _target/release_ içindeki çalıştırılabilir dosyayı
ile kıyasladığınızdan emin olun.

### Sözleşme olarak cargo

Basit projelerde, Cargo sadece
`rustc` kullanmaktan çok fazla değer sağlamaz, ancak programlarınız daha karmaşık hale geldikçe değerini kanıtlayacaktır.
Programlar birden fazla dosyaya ulaştığında veya bir bağımlılığa ihtiyaç duyduğunda,
Cargo'nun derlemeyi koordine etmesine izin vermek çok daha kolaydır.

Hello_cargo` projesi basit olmasına rağmen, Rust kariyerinizin geri kalanında kullanacağınız gerçek
araçlarının çoğunu kullanıyor. Aslında, herhangi bir
mevcut proje üzerinde çalışmak için, Git kullanarak
kodunu kontrol etmek, bu projenin dizinine geçmek ve derlemek için aşağıdaki komutları kullanabilirsiniz:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

Cargo hakkında daha fazla bilgi için [belgelerine][cargo] göz atın.

## Özet

Rust yolculuğunuza harika bir başlangıç yaptınız bile! Bu bölümde
nasıl yapılacağını öğrendiniz:

- Rust'ın en son kararlı sürümünü `rustup` kullanarak yükleyin
- Daha yeni bir Rust sürümüne güncelleme
- Yerel olarak yüklenmiş belgeleri açın
- Doğrudan `rustc` kullanarak bir “Merhaba, dünya!” programı yazın ve çalıştırın
- Cargo kurallarını kullanarak yeni bir proje oluşturun ve çalıştırın

Bu,
adresini okumaya ve Rust kodu yazmaya alışmak için daha önemli bir program oluşturmanın harika bir zamanıdır. Bu yüzden, Bölüm 2'de bir tahmin oyunu programı oluşturacağız.
Yaygın programlama kavramlarının
Rust'ta nasıl çalıştığını öğrenerek başlamayı tercih ederseniz, Bölüm 3'e bakın ve ardından Bölüm 2'ye dönün.

[installation]: ch01-01-installation.md#kurulum
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.md
[cargo]: https://doc.rust-lang.org/cargo/
